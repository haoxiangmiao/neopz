// -*- c++ -*-
// $Id: pzadaptmesh.h,v 1.2 2005-02-28 22:09:57 phil Exp $
/* Generated by Together */

#ifndef TPZADAPTMESH_H
#define TPZADAPTMESH_H

#include "pzcmesh.h"
#include "pzcclonemesh.h"
#include "pzvec.h"

#include <pthread.h>

class TPZInterpolatedElement;
class TPZTransfer;
class TPZTransform;
template<class T, class V>
class TPZAvlMap;
class TPZOneDRef;

/// interface to generate adapted meshes
class TPZAdaptMesh {
 public:
  

  /**
   * Simple constructor
   */
  TPZAdaptMesh(TPZCompMesh *mesh);
  
  /**
   * Simple destructor
   */
  ~TPZAdaptMesh();
  
  /**
   * Defines the maximum p order of an element
   */
  void SetMaxP(int maxp);
  
  /**
   * Public interface to get the optmally refined mesh 
   * @param error: returns the estimated error
   * @param truerror: returns the true error if analitical solution is provided
   * @param ervec: estimated element error for original mesh element vector
   * @param f: analitical solution
   * @param truervec: real element error at each orginal mesh element
   * @param effect: error estimator effectivity
   * @param use_trueerror: evaluates the error throgh the analitical solution provided by f
   */
  void GetAdaptedMesh(TPZStack<TPZGeoEl *> &gelstack,TPZStack<int> &porders,
		      REAL &error,
		      REAL &truerror,
		      TPZVec<REAL> &ervec, 
		      void (*f)(TPZVec<REAL> &loc,TPZVec<REAL> &val,TPZFMatrix &deriv),
		      TPZVec<REAL> &truervec, 
		      TPZVec<REAL> &effect,
		      int use_trueerror = 0);


  /**
   * returns the error based on a function pointer which returns the analytic solution
   */
static REAL ComputeTrueError(TPZInterpolatedElement *coarse, void (*f)(TPZVec<REAL> &loc, TPZVec<REAL> &val, TPZFMatrix &deriv));


  //multi-threading control variables...
  static int fThreads_in_use;

 private:
  static int fNClones_to_Analyse;

 protected:
  
  
  /**
   * Retrieves the geometric reference elements to create the patches 
   */
  void BuildReferenceElements();
  
  /**
   * Builds the patch of all reference elements. 
   * The patches are stored into patch vectors
   */   
  void BuildReferencePatch();
  
  /**
   * return the number of patches
   */
  int NPatches();
  /**
   * Fill the vector of clone meshes
   */
  void CreatePatch(int cloneindex);
  
  /**
   * Sorts the elements by the error vector vec, returning permutation vector
   */
static  void Sort(TPZVec<REAL> &vec, TPZVec<int> &perm);
  
  /**
   * Sort
   */
static  void HeapSort(TPZVec<REAL> &sol, TPZVec<int> &perm);
  
  /**
   * Sorts the errvec returning the ordering indexes in perm param.
   * errpercent is the percentual of the error that must be considered in returning minimum error
   */
static  REAL TPZAdaptMesh::SortMinError (TPZVec<REAL> &errvec, TPZVec<int> &perm, REAL errpercent);

  /**
   * Creates an adpted computational mesh based on original mesh and in a hp refinement pattern also
   * @param mesh: original mesh
   * @param gelstack: h refinement pattern given by a list of an adapted geometric elements
   * @param porders: p refinement pattern for each element of gelstack
   */
public:
static TPZCompMesh* CreateCompMesh (TPZCompMesh *mesh,TPZVec<TPZGeoEl *> &gelstack,TPZVec<int> &porders);
protected:
  /**
   * Verifies if one clone, specified by its index, must be analysed \
   * This method only be called when the true solution is available and the \
   * option usetrueerror in void  GetAdaptedMesh is set to 1.
   * @param clindex index of the clone to be verified
   * @param minerror minimum error to the clone be analysed
   * @param ervec vector containing the treu error 
   */
  int TPZAdaptMesh::HasLargeError(int clindex, REAL &minerror, TPZVec<REAL> &ervec);


 private:
  /**
   * Delete all elements which have Material Id == -1000
   */
  static void RemoveCloneBC(TPZCompMesh *mesh);
  /**
   * Delete the elements in an orderly fashion
   */
  static void DeleteElements(TPZCompMesh *mesh);
  /**
   * returns a pointer to the element by which the parameter is restrained
   * @param cint element which has restrained connectivities
   * @return the element which contains the unconstrained connectivity
   */
  static TPZInterpolatedElement * LargeElement(TPZInterpolatedElement *cint);
  /**
   * Computational reference mesh
   */
  TPZCompMesh *fReference;
  
  /**
   * Geometric reference elements vector
   */
  TPZStack < TPZGeoEl * > fGeoRef;
  
  /**
   * Patches vector
   */
  TPZStack < TPZGeoEl * > fPatch;
  
  /**
   * Maps the start position of each patch into patches vector
   */
  TPZStack < int > fPatchIndex;
  
  /**
   * Element error vector
   */
  TPZStack < REAL > fElementError;

  /**
   * True Element error vector
   */
  TPZVec < REAL > fTrueErrorVec;
  
  /**
   * this struct groups all information pertinent to a patch of elements
   */
  struct TPZCloneInfo {  

    /**
     * Clone meshes vector
     */
    TPZCompCloneMesh * fCloneMesh;

    /**
     * Refined clone meshes
     */
    TPZCompMesh * fFineCloneMesh;

    /**
     * contains the element pointers if the element should be refined either in h or p
     */
    TPZStack<TPZGeoEl *> fRefinedElements;
    /**
     * contains the order of the refined elements
     */
    TPZStack<int> fRefinedOrders;

    /**
     * contains pointers to the original element if it shouldn t be refined
     */
    TPZStack<TPZGeoEl *> fOriginalElements;
    /**
     * contains the order of the original element
     */
    TPZStack<int> fOriginalOrders;

    /**
     * Initializes the data structure
     */ 
    TPZCloneInfo();

    /**
     * deletes the cloned meshes as these are no longer needed
     */
    void Cleanup();

    /**
     * will add the refined or original elements depending on the value of minerror to gelstack and orders
     */
    void AddSelectedElements(TPZVec<REAL> &errvec, REAL minerror,TPZStack<TPZGeoEl *> &gelstack, TPZStack<int> &orders);

    void PrintElementIds(ostream &out);
    /**
     * Deletes all dynamically allocated datastructure
     */
    ~TPZCloneInfo();
  };

  TPZManVector<TPZCloneInfo> fCloneStructs;

  /**
   * Indexes of the clones that must be analysed
   */

  TPZStack <int> fClonestoAnalyse;
  /** 
   * Delete temporary clone meshes from memory
   */
  void CleanUp();

  /**
   * Will create a clone mesh and analyse the error of its elements
   * Will also delete the temporary data structures created for the analysis
   */
  void ProcessPatch(int clone);

  /**
   * Mesh Error void -- to be used in multi-threading
   */
  static void  * MeshError (void *t);

  void (*fExact)(TPZVec<REAL> &loc, TPZVec<REAL> &result, TPZFMatrix &deriv);

  /*
   * Maximum p order of an element
   */
  int fMaxP;

  static  pthread_mutex_t fLock_clindex;
  static  pthread_cond_t fSignal_free;
  
};
#endif //TPZADAPTMESH_H
