 /***************************************************************************
 *   Copyright (C) 2009 by joao *
 *   joao@joao-laptop   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "pzgengrid.h"
#include "pzgmesh.h"
#include "pzcmesh.h"
#include "pzcompel.h"
#include "pzheat.h"
#include "pzbndcond.h"


#include "pzstepsolver.h"
#include "TPZParFrontStructMatrix.h"
#include "TPZSpStructMatrix.h"
#include "pzbstrmatrix.h"
#include "pzblockdiag.h"
#include "pzbdstrmatrix.h"
#include "tpzsparseblockdiagonalstructmatrix.h"
#include "pzskylstrmatrix.h"
#include "TPZParSkylineStructMatrix.h"
#include "pzbndmat.h" 
#include "pzfstrmatrix.h"
#include "pzmatrix.h"
#include "pzfmatrix.h"

#include "TPZCompElDisc.h"
#include "TPZInterfaceEl.h"
#include "tpzautopointer.h"
#include "math.h"
#include "pzlog.h"
#include <sstream>
#include <fstream>
#include "tpzcopysolve.h"

#include "TPZTimer.h"
#include "ffunction.h" /// esse include eh importante pq eh em ffunction.h que passamos as solucoes exatas
										/// e as condicoes de contorno não homogeneas.
#include "TPZRefPattern.h"
#include "pzgeoquad.h"
#include "pzespmat.h"

#include "pztransientanalysis.h"
#include "pzl2projection.h"


// PARABÓLICO
using namespace std;

/*----------MALHAS-----------*/

TPZGeoMesh * MalhaGeo ( const int h );
TPZCompMeshReferred *CreateCompMesh ( TPZGeoMesh &gmesh, int porder );
TPZCompMeshReferred *CreateCompMeshProjection ( TPZGeoMesh &gmesh, int porder );

/*----------SOLVERS----------*/
void SolveIterative(TPZAnalysis &an);
void SolveTransient ( TPZAnalysis &an, TPZAnalysis &anProjection );

/*------------GRAFICOS---------------*/
void SolutionGrafic(TPZAnalysis& an_p1,ofstream& AE, int h, int p, ofstream& OUT);
void SolutionError(TPZAnalysis& an ,ofstream& AE,  int h, int p, ofstream& OUT);
 
void Load (TPZCompMeshReferred *primal1,TPZCompMeshReferred *primal2);

int main() 
{

	TPZHeat::fPrimalExactSolution = ffunction::ExactSolution_primal;
	
	/* Dados iniciais*/
	int h=0;
	int p=2; 

	
	std::ofstream AE ( "results.txt" );
	AE.precision(16);
	
	for(h=2;h<3;h++)
	{		
		TPZGeoMesh *gmesh = MalhaGeo(h);
		
		TPZCompMeshReferred *cmeshProjection = CreateCompMeshProjection(*gmesh,p);
		cmeshProjection->SetName ( "cmeshProjection" );
		TPZTransientAnalysis anProjection(cmeshProjection);
		gmesh->ResetReference();
		TPZCompMeshReferred *cmesh = CreateCompMesh(*gmesh,p);
		cmesh->SetName ( "cmesh" );
		TPZAnalysis an(cmesh);
		Load(cmeshProjection, cmesh);
		
		SolveTransient( an, anProjection );

//		SolutionGrafic(anProjection, AE, h, p, AE);
	}

	
	return EXIT_SUCCESS;
}

TPZGeoMesh * MalhaGeo( const int h ){
	TPZGeoMesh *gmesh = new TPZGeoMesh();
	REAL co[4][2] = {{0.,0.},{1.,0.},{1.,1.},{0.,1.}}; 
	TPZGeoEl *elvec[1];//[2];
	int nnode = 4;
	int nelem = 1;//2;
	int nod;
	for ( nod=0; nod<nnode; nod++ )
	{
		int nodind = gmesh->NodeVec().AllocateNewElement();
		TPZVec<REAL> coord ( 2 );
		coord[0] = co[nod][0];
		coord[1] = co[nod][1];
		gmesh->NodeVec() [nodind].Initialize ( nod,coord,*gmesh );
	}
	
	int el;
	
	//int nodindAll[2][3]={{0,1,2},{2,3,0}};
	int nodindAll[1][4]={{0,1,2,3}};
	for ( el=0; el<nelem; el++ )
	{
		TPZVec<int> nodind(4);//(3);
		nodind[0]=nodindAll[el][0];
		nodind[1]=nodindAll[el][1];
		nodind[2]=nodindAll[el][2];
		nodind[3]=nodindAll[el][3];		
		int index;
		//elvec[el] = gmesh->CreateGeoElement (ETriangle,nodind,1,index );
		elvec[el] = gmesh->CreateGeoElement (EQuadrilateral,nodind,1,index );		
	}
//	int nodindAll[1][4]={{0,1,2,3}};
//	for ( el=0; el<nelem; el++ )
//	{
//		TPZVec<int> nodind(4);
//		nodind[0]=nodindAll[el][0];
//		nodind[1]=nodindAll[el][1];
//		nodind[2]=nodindAll[el][2];
//		nodind[3]=nodindAll[el][3];
//		int index;
//		elvec[el] = gmesh->CreateGeoElement (EQuadrilateral,nodind,1,index );
//	}
	
	
	gmesh->BuildConnectivity();
	
	TPZGeoElBC gbc1 ( elvec[0],4,-1);
	TPZGeoElBC gbc2 ( elvec[0],5,-2);
	TPZGeoElBC gbc3 ( elvec[0],6,-3);
	TPZGeoElBC gbc4 ( elvec[0],7,-4);
	
//	TPZGeoElBC gbc1 ( elvec[0],3,-1);
//	TPZGeoElBC gbc2 ( elvec[0],4,-2);
//	TPZGeoElBC gbc3 ( elvec[1],3,-3);
//	TPZGeoElBC gbc4 ( elvec[1],4,-4);
	
//	TPZGeoElBC gbc5 ( elvec[0],0,-5);// um ponto (a origem)
	
	ofstream arcg ( "gmesh.txt" );
	gmesh->Print ( arcg );
	
	///Refinamento uniforme
	for ( int ref = 0; ref < h; ref++ )
	{// h indica o numero de refinamentos
		TPZVec<TPZGeoEl *> filhos;
		int n = gmesh->NElements();
		for ( int i = 0; i < n; i++ )
		{
			TPZGeoEl * gel = gmesh->ElementVec() [i];
			if ( gel->Dimension() == 2 ) gel->Divide ( filhos );
		}//for i
	}//ref
	return gmesh;
}

TPZCompMeshReferred *CreateCompMesh ( TPZGeoMesh &gmesh, int porder ){
	TPZCompEl::SetgOrder ( porder );
	TPZCompMeshReferred *result = new TPZCompMeshReferred( &gmesh );
	result->SetDimModel ( 2 );
	//result->SetAllCreateFunctionsDiscontinuous(); 
	result->SetAllCreateFunctionsContinuous();
	
	TPZHeat *material ;
	material = new TPZHeat ( 1,2 );
	
	TPZVec<REAL> convdir(3);//direção da convecção
	convdir[0]=0.;
	convdir[1]=0.;
	REAL diff= 1.;
	REAL conv= 0.;
	material-> SetParameters(diff, conv, convdir);
	TPZAutoPointer<TPZMaterial> mat ( material );
	//material->SetNonSymmetric();
	material->SetSymmetric();
	
	material->SetForcingFunction ( ffunction::Forcing1 );
	result->InsertMaterialObject ( mat );
	
	TPZFMatrix val1 ( 1,1,0. ), val2 ( 1,1,0. );// 0 é Dirichlet, 1 é Neumann, 2 é Robin(implementada apenas no Contínuo)

	TPZAutoPointer<TPZMaterial> bnd1 = material->CreateBC ( mat,-1,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd2 = material->CreateBC ( mat,-2,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd3 = material->CreateBC ( mat,-3,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd4 = material->CreateBC ( mat,-4,0, val1, val2 );
	
	bnd1->SetForcingFunction ( ffunction::CC1 );
	bnd2->SetForcingFunction ( ffunction::CC2 );
	bnd3->SetForcingFunction ( ffunction::CC3 );
	bnd4->SetForcingFunction ( ffunction::CC4 ); 
	
	result->InsertMaterialObject ( bnd1 ); 
	result->InsertMaterialObject ( bnd2 );
	result->InsertMaterialObject ( bnd3 );
	result->InsertMaterialObject ( bnd4 );
	
	result->AutoBuild();
	//
	ofstream arc ( "cmesh.txt" );
	arc << "NEquation = "<< result->NEquations() << endl;
	result->Print ( arc );
	ofstream arcg ( "gmesh.txt" );
	result->Reference()->Print ( arcg );
	//
	result->SetName("CMesh1");
	//
	return result;
}

TPZCompMeshReferred *CreateCompMeshProjection ( TPZGeoMesh &gmesh, int porder ){
	TPZCompEl::SetgOrder ( porder );
	TPZCompMeshReferred *result = new TPZCompMeshReferred( &gmesh );
	result->SetDimModel ( 2 );
	//result->SetAllCreateFunctionsDiscontinuous(); 
	result->SetAllCreateFunctionsContinuous();
	
	TPZL2Projection *material ;
	TPZVec<REAL> Sol;
	material = new TPZL2Projection ( 1,2, 1, Sol );
	
//	TPZL2Projection(int id, int dim, int nstate, TPZVec<REAL> &sol,int IntegrationOrder = -1);
	
	TPZAutoPointer<TPZMaterial> mat ( material );
	
	material->SetForcingFunction ( ffunction::ForcingInitialCondition );
	result->InsertMaterialObject ( mat );
	
	TPZFMatrix val1 ( 1,1,0. ), val2 ( 1,1,0. );// 0 é Dirichlet, 1 é Neumann, 2 é Robin(implementada apenas no Contínuo)
	
	TPZAutoPointer<TPZMaterial> bnd1 = material->CreateBC ( mat,-1,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd2 = material->CreateBC ( mat,-2,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd3 = material->CreateBC ( mat,-3,0, val1, val2 );
	TPZAutoPointer<TPZMaterial> bnd4 = material->CreateBC ( mat,-4,0, val1, val2 );
	
	bnd1->SetForcingFunction ( ffunction::CC1Projection );
	bnd2->SetForcingFunction ( ffunction::CC2Projection );
	bnd3->SetForcingFunction ( ffunction::CC3Projection );
	bnd4->SetForcingFunction ( ffunction::CC4Projection ); 
	
	result->InsertMaterialObject ( bnd1 ); 
	result->InsertMaterialObject ( bnd2 );
	result->InsertMaterialObject ( bnd3 );
	result->InsertMaterialObject ( bnd4 );
	
	result->AutoBuild();
	//
	ofstream arc ( "cmesh.txt" );
	arc << "NEquation = "<< result->NEquations() << endl;
	result->Print ( arc );
	ofstream arcg ( "gmesh.txt" );
	result->Reference()->Print ( arcg );
	//
	result->SetName("CMesh1");
	//
	return result;
}

/**------------------------- SOLVERS -------------------------*/
void SolveIterative( TPZAnalysis &an ){
	TPZCompMesh *malha = an.Mesh();
	
	//TPZBandStructMatrix mat(malha);
	//TPZParFrontStructMatrix<TPZFrontNonSym> mat(malha);
	//TPZParFrontStructMatrix mat(malha);
	//TPZFrontStructMatrix<TPZFrontNonSym> mat ( malha );// não funciona com método iterativo
	//TPZFStructMatrix mat( malha );
	TPZSpStructMatrix mat( malha );
	TPZStepSolver solv;
		
	TPZFMatrix fakeRhs(malha->NEquations(),1);
	//TPZSkylineStructMatrix PrecondMatrix(malha);
	//TPZParSkylineStructMatrix PrecondMatrix(malha, 1);
	TPZFrontStructMatrix<TPZFrontNonSym>PrecondMatrix(malha);
//	PrecondMatrix.SetNumberOfThreads(4);
	//TPZBlockDiagonalStructMatrix PrecondMatrix(malha);
	
	TPZAutoPointer<TPZGuiInterface> guiInterface1 = new TPZGuiInterface();//
	TPZStepSolver precond(PrecondMatrix.CreateAssemble(fakeRhs, guiInterface1));

	precond.SetDirect(ELU);//ELU //ECholesky // ELDLt
	
 	solv.SetGMRES( 100000, 50, precond, 1.e-15, 0 );
	//solv.SetCG(10000, precond, 1.e-16, 0);	
	//solv.SetJacobi(1000, 1.e-15, 0)
	//solv.SetBiCGStab();
	//solv.SetSOR();
	//solv.SetSSOR();
	
	cout << "ELU " << endl;
	an.SetSolver ( solv );
	an.SetStructuralMatrix ( mat );
	cout << endl;
	an.Solution().Redim ( 0,0 );
	cout << "Assemble " << endl;
	an.Assemble();
	an.Solve();
	
	cout << endl;
	cout << "No equacoes = " << malha->NEquations() << endl;
	cout << "Banda = " << malha->BandWidth() << endl;
}


void SolveTransient ( TPZAnalysis &an, TPZAnalysis &anProjection)
{
	std::ofstream AE ( "results.txt" );
	AE.precision(16);
	
	TPZCompMesh *ProjectionCMesh = anProjection.Mesh();
	TPZBandStructMatrix matProj(ProjectionCMesh);
	TPZAutoPointer<TPZGuiInterface> guiInterface;
	TPZFMatrix RhsProjection;
	TPZFMatrix Un;

	TPZAutoPointer <TPZMatrix> MassMatrix = matProj.CreateAssemble(RhsProjection,guiInterface);
	
	anProjection.SetStructuralMatrix ( matProj );
	TPZStepSolver solvProjection;
	solvProjection.SetDirect ( ELDLt);//ECholesky);// ELU , ELDLt , 
	cout << "ELU " << endl;
	anProjection.SetSolver ( solvProjection );

	cout << endl;
	anProjection.Solution().Redim ( 0,0 );
	cout << "Assemble " << endl;
	anProjection.Assemble();
	anProjection.Solve();
	Un = anProjection.Solution();	
	anProjection.LoadSolution(Un);
	
	Un.Print("U_0 = ", std::cout,EMathematicaInput);
	
	MassMatrix->Print("Mass = ", std::cout,EMathematicaInput);
	
	
	SolutionGrafic(anProjection, AE, 1, 1, AE);
	
	TPZCompMesh *malha = an.Mesh();
	TPZBandStructMatrix mat(malha);
	TPZStepSolver solv;
	solv.SetDirect ( ELDLt);//ECholesky);// ELU , ELDLt , 
	cout << "ELDLt " << endl;
	an.SetSolver ( solv );
	an.SetStructuralMatrix ( mat );
	cout << endl;
	an.Solution().Redim ( 0,0 );
	cout << "Assemble " << endl;
	an.Assemble();
	

	TPZFMatrix FLoad; //vetor de carga
	FLoad = an.Rhs();
	FLoad.Print("FLoad = ", std::cout,EMathematicaInput);

	int nrows;
	nrows = Un.Rows();
	TPZFMatrix TotalRhstemp(nrows,1,0.0);
	TPZFMatrix TotalRhs(nrows,1,0.0);
	
	//loop no tempo
	for(int t=1;t<11;t++)//delta t = 1
	{
	//atualizacao lado direito
	MassMatrix->Multiply(Un,TotalRhstemp);
	TotalRhs = FLoad + TotalRhstemp;
	an.Rhs() = TotalRhs;
	an.Solve();
		
	
	SolutionGrafic(an, AE, 0, 0, AE);
	SolutionError(an, AE, 0, 0, AE);
	Un=an.Solution();
	}
	cout << endl;
	cout << "No equacoes = " << malha->NEquations() << endl;
}




/** ------------------------- GRÁFICOS -------------------------*/
void SolutionGrafic(TPZAnalysis& an ,ofstream& AE,  int h, int p, ofstream& OUT){

	AE<<"------------------------------------"<<endl;
	AE << "hxh, h="<< h<< ", p="<< p<< endl;
	AE << "DOF = " <<  an.Mesh()->NEquations()    << endl;
	AE<<"------------------------------------"<<endl;
	
	
	/// Saida de Dados primal1
	/// 1. Coeficientes da Solucao Numerica 
	//         ofstream filep1("Solution_primal1.out");
	//         TPZFMatrix toprintp1 = an_p1.Solution();
	//         toprintp1.Print("solution", filep1);
	///2. Saida para dx ou vtk
	TPZVec<std::string> scalar_names(1);
	TPZVec<std::string> vec_names(0);

	scalar_names[0] = "Solution";
//	scalar_names[1] = "dx";
//	scalar_names[2] = "dy";
//	scalar_names[3] = "ExactSolution";
//	scalar_names[4] = "Exactdx";
//	scalar_names[5] = "Exactdy";
	
	
	char buf[256] ;
	sprintf(buf,"iteracao_h%d_p%d.vtk",h,p); 
	an.DefineGraphMesh(2, scalar_names, vec_names,buf);

	an.PostProcess(2);// o parametro é a resolução que será acrescida na visualização.
}

void SolutionError(TPZAnalysis& an ,ofstream& AE,  int h, int p, ofstream& OUT){
///Plotar as normas dos erros 
an.SetExact(ffunction::ExactSolution_primal);
TPZVec<REAL> pos;
an.PostProcess(pos,AE); // Calcula os erros.(pzanalysis.cpp)
}



void Load (TPZCompMeshReferred *primal1,TPZCompMeshReferred *primal2){
	TPZGeoMesh *gmesh = primal1->Reference();
	primal1->LoadReferred ( primal2 );
	primal2->ResetReferred();
	
	gmesh->ResetReference();
	primal1->LoadReferences();
	primal1->CleanUpUnconnectedNodes();
	primal1->ExpandSolution();
	
	gmesh->ResetReference();
	primal2->LoadReferences();
	primal2->CleanUpUnconnectedNodes();
	primal2->ExpandSolution();
}

