/*
 *  TPZYCMohrCoulomb.h
 *  FEMPZ
 *
 *  Created by Diogo Cecilio on 4/29/10.
 *  Copyright 2010 __MyCompanyName__. All rights reserved.
 *
 */

/* Generated by Together */// $Id: TPZYCMohrCoulomb.h,v 1.24 2009-09-24 04:19:52 Diogo Exp $

#ifndef TPZYCMODIFIEDMOHRCOULOMB_H
#define TPZYCMODIFIEDMOHRCOULOMB_H

#include "TPZTensor.h"
#include "pzlog.h"


#ifdef LOG4CXX_PLASTICITY
static LoggerPtr logModifiedMohr(Logger::getLogger("TPZYCMohr"));
#endif

class TPZYCModifiedMohrCoulomb  {
	
public:
	
	enum {NYield = 1};
    
    const char * Name() const
    {
		return "TPZYCModifiedMohrCoulomb";	
    }
	
    void Print(std::ostream & out) const
    {
		out << Name();
    }
    
	int GetForceYield()
	{
		return 0; // nothing to be done in this yield criterium
	}
	
	void SetForceYield(const int forceYield)
	{
		// nothing to be done in this yield criterium
	}
	
	/**
	 * Checks if the proposed yield state leads to post-peak material behaviour. If so, the material
	 * is forced to behave in post-peak in order to avoid equation switching during Newton's method
	 * in the PlasticLoop routines.
	 * @param [in] sigma stress state
	 * @param [in] A Thermo Force
	 */
	void SetYieldStatusMode(const TPZTensor<REAL> & sigma, const REAL & A)
	{
		// nothing to be done in this yield criterium
	}
	
	
	/**
	 * Setup of material parameters
	 * @param [in] phi Mohr Coulomb's internal friction angle
	 * @param [in] innerMCFit If one, Drucker Prager model is inscribed in a referred Mohr Coulomb envelope. If zero, circumscribed.
	 * VERY IMPORTANT!! The ThermoForceA parameters should be set as:
	 *      fk: Herdening slope for the cohesion
	 *      fYield0 : equivalent Mohr Coulomb cohesion C
	 */
	void SetUp(const REAL & phi, const int innerMCFit) 
	{
		fPhi = phi;
		fPi = M_PI;
	}
	
	
	/**
	 * Evaluate the yield criteria
	 * @param [in] sigma current stress tensor
	 * @param [in] A current thermodynamical force
	 * @param [out] result
	 * @param [in] checkForcedYield indicates wether to force post-peak failure behavior
	 */
	template < class T>
	void Compute(const TPZTensor<T> & sigma, const T & A, TPZVec<T> &result, int checkForcedYield = 0) const;
	
	/**
	 * Derivative of the yield function
	 * @param [in] sigma current stress tensor
	 * @param [in] A current thermodynamical force
	 * @param [out] Ndir Stress derivative
	 * @param [in] checkForcedYield indicates wether to force post-peak failure behavior
	 */
	template <class T>
	void N(const TPZTensor<T> & sigma,const T & A,  TPZVec<TPZTensor<T> > & Ndir, int checkForcedYield = 0) const;
	
	/**
	 * Derivative of the yield function with respect to the thermodynamical force
	 * @param [in] sigma current stress tensor
	 * @param [in] A current thermodynamical force
	 * @param [out] h Derivative with respect to thermodynamical force
	 * @param [in] checkForcedYield indicates wether to force post-peak failure behavior
	 */
	template <class T>
	void H(const TPZTensor<T> & sigma,const T & A,  TPZVec<T> & h, int checkForcedYield = 0) const
	{
		h[0] = cos(fPhi);
	}
	
	template <class T>
	void GradLodeAngle(const TPZTensor<T> &sigma, TPZTensor<T> &grad, T &theta) const;
	
	template <class T>
	void dpart1(const TPZTensor<T> &sigma, TPZTensor<T> &grad) const;
	
	
	template <class T>
	void respart1(const TPZTensor<T> &sigma, REAL &phi) const;
	
	template <class T>
	void dpart2(const TPZTensor<T> &sigma, TPZTensor<T> &grad) const;
	
	
	template <class T>
	void respart2(const TPZTensor<T> &sigma, REAL &phi) const;
	
	//////////////////CheckConv related methods/////////////////////
	
    /**
	 number of types of residuals
	 */
    int NumCases() 
    {
		return 5;
    }
	TPZTensor<REAL> gRefTension;
	
    /**
	 LoadState will keep a given state as static variable of the class
	 */
    void LoadState(TPZFMatrix &state)
    {
		int i;
		for(i=0; i<6; i++) gRefTension.fData[i] = state(i,0);
    }
    void ComputeTangent(TPZFMatrix &tangent, TPZVec<REAL> &coefs, int icase)
    {
		switch(icase)
		{
			case 0:
			{
				TPZTensor<REAL> grad;
				this->gRefTension.dJ2(grad);
				tangent.Redim(1,6);
				int i;
				for(i=0; i<6; i++)
				{
					tangent(0,i) = grad.fData[i];
				}
			}
				break;
			case 1:
			{
				TPZTensor<REAL> grad;
				this->gRefTension.dJ3(grad);
				tangent.Redim(1,6);
				int i;
				for(i=0; i<6; i++)
				{
					tangent(0,i) = grad.fData[i];
				}
			}
				break;
			case 2:
			{
				REAL yield = 1.e6;
				TPZVec<TPZTensor<REAL> > grad(1);
				this->N<REAL>(gRefTension,yield,grad,0);
				tangent.Redim(1,6);
				int i;
				for(i=0; i<6; i++)
				{
					tangent(0,i) = grad[0].fData[i];
				}
			}
				break;
			case 3:
			{
				REAL theta;
				TPZTensor<REAL> grad;
				this->GradLodeAngle<REAL>(gRefTension,grad,theta);
				tangent.Redim(1,6);
				int i;
				for(i=0; i<6; i++)
				{
					tangent(0,i) = grad.fData[i];
				}
				break;
			}
			case 4:
			{
				TPZTensor<REAL> grad;
				dpart1(gRefTension,grad);
				tangent.Redim(1,6);
				int i;
				for(i=0; i<6; i++)
				{
					tangent(0,i) = grad.fData[i];
				}
				
			}
		}
    }
	
    void Residual(TPZFMatrix &res,int icase)
    {
		
		res.Redim(1,1);
		TPZTensor<REAL> grad;
		
		switch(icase)
		{
			case 0:
			{
				res(0,0) = gRefTension.J2();
				break;
			}
			case 1:
			{
				res(0,0) = gRefTension.J3();
				break;
			}
			case 2:
			{
				TPZVec<REAL> phi(1);
				REAL yield = 1.e6;
				this->Compute(gRefTension,yield,phi,0);
				res(0,0) = phi[0];
				break;
			}
			case 3:
			{
				REAL theta;
				GradLodeAngle<REAL>(gRefTension,grad,theta);
				res(0,0) = theta;
				break;
			}
			case 4:
			{
				REAL phi;
				respart1(gRefTension, phi);
				res(0,0)=phi;
				break;
				
			}
		}
		
    }
	
	//////////////////CheckConv related methods/////////////////////
	
public:
	
protected:
	
	REAL fKsi, fEta, fPhi,fCoesion,fPi;
	
};

/**
 * Calculo do criterio de plastificacao
 * @param [in] sigma tensao atual
 * @param [in] A forca thermodinamica atual
 */
template < class T>
void TPZYCModifiedMohrCoulomb::Compute(const TPZTensor<T> & sigma, const T & A,TPZVec<T> &result, int checkForcedYield) const
{
	
	TPZTensor<T> grad;
	T theta;
	GradLodeAngle<T> (sigma, grad,theta);
	
	T I1 = sigma.I1();
	T J2 = sigma.J2();
	T J3 = sigma.J3();
	T p =I1/T(3.);
	REAL coesion = 9.2376;

		//ANGULO SOUSA NETO
		if(fabs( shapeFAD::val(J2) ) < 1.e-6)J2 = 1.e-6;
		T temp = ( T( 3.) * sqrt( T( 3.) ) * J3 ) /( T( 2.) *  sqrt(J2*J2*J2) );
		if( temp >= T(1.))
		{
			temp*=T(0.999);
		}
		if(temp <= T(-1.))
		{
			temp*=T(0.999);
		}
		T theta2=-asin( temp )/T( 3.);
		//FUNCAO NETO
		result[0]=-( T(coesion) * cos( T( fPhi ) ) ) + p * sin(T( fPhi )) + sqrt ( J2 ) * ( cos(theta2) - ( sin(T( fPhi ) ) * sin ( theta2 )) / sqrt( T(3.) ) );
	
#ifdef LOG4CXX_PLASTICITY
		{
			std::stringstream sout;
			sout << "\nVALORES DO LODE ANGLE E DA FUNCAO DE MOHR REFERENTE AO LIVRO DO EDUARDO SOUZA NETO! \n"<<endl;
			sout << "SIGMA = "<<sigma<<endl;
			sout << "FRICTIONAL_ANGLE = "<<fPhi<<endl; 
			sout << "theta_NETO = "<< theta2 << endl;
			sout << "NVEC = "<< grad << endl;
			sout << "FUNCTIONAL_VALUE_NETO =  "<<result[0];
			sout << "\n\n";
			LOGPZ_INFO(logModifiedMohr,sout.str());
		}
#endif
	
}

/**
 * Derivada da funcao de plastificacao
 * @param [in] sigma tensao atual
 * @param [in] A forca termodinamica atual
 * @param [out] Derivida com respeito a tensao
 */
template <class T> 
void TPZYCModifiedMohrCoulomb::N(const TPZTensor<T> & sigma,const T & A,  TPZVec<TPZTensor<T> > & Ndir, int checkForcedYield) const
{
	
	TPZTensor<T> gradtheta;
	T theta;
	GradLodeAngle<T> (sigma, gradtheta,theta);
	T J2 = sigma.J2();
	
	T J3=sigma.J3();
	if(fabs( shapeFAD::val(J2) ) < 1.e-6)J2 = 1.e-6;
	T sqj2 = sqrt(J2);
	TPZTensor<T> dj2,di1,I;
	sigma.dJ2(dj2);
	di1.XX()=1.;
	di1.YY()=1.;
	di1.ZZ()=1.;
//	REAL Phi = 0.349066;
//	I.Identity();
//	
//	T temp1 = sqj2 * ( ( -sin( theta ) ) - ( ( T( 1. ) / T( sqrt ( 3. ) ) ) *  cos( theta ) * sin( T( fPhi ) )  ) );
//	TPZTensor<T> resultdtheta(gradtheta);
//	
//	resultdtheta.Multiply(temp1,T(1.));
//	
//	T temp2 = (T(1.)/(T(2.) * sqj2)) * ( cos(theta) - (T(1.)/T(sqrt(3.)))* sin(theta) * sin(fPhi) );
//	TPZTensor<T> resultdj2(dj2);
//	resultdj2.Multiply(temp2,T(1.));
//	
//	resultdtheta.Add(resultdj2,1.);
//	
//	T temp3 = T(1./3.) * sin( T( fPhi ) );
//	TPZTensor<T> result(I);
//	result.Multiply(temp3,T(1.));
//	
//	resultdtheta.Add(result,T(1.));
//	
//	Ndir[0]=resultdtheta;
	
	//(2*di1*Sqrt(j2)*Sin(phi) - 2*j2*gradtheta*(Sqrt(3)*Cos(theta)*Sin(phi) + 3*Sin(theta)) + dj2*(3*Cos(theta) - Sqrt(3)*Sin(phi)*Sin(theta)))/(6.*Sqrt(j2))
	T temp1 = T(2.)*sqrt(J2)*sin(fPhi);//dI1
	T temp2 = - T(2.)*J2*(sqrt(T(3.))*cos(theta)*sin(fPhi) + T(3.)*sin(theta));//GRADTHETA
	T temp3 = (T(3.)*cos(theta) - sqrt(T(3.))*sin(fPhi)*sin(theta));//dJ2
	di1.Multiply(temp1,T(1.));
	gradtheta.Multiply(temp2,T(1.));
	dj2.Multiply(temp3, T(1.));
	di1.Add(gradtheta,T(1.));
	di1.Add(dj2, T(1.));
	di1.Multiply(T(1.)/(T(6.)*sqrt(J2)), T(1.));
	Ndir[0]=di1;
	
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n NVECTOR "<<endl;
		sout << "\nfPHI "<<endl;
		sout << fPhi <<endl;
		sout << "\nGRADTHETA "<<endl;
		sout << gradtheta <<endl;
		sout << "\nPRIMEIRA PARTE "<<endl;
	//	sout << resultdtheta <<endl; 
		sout << "\nSEGUNDA PARTE "<<endl;
	//	sout << resultdj2 <<endl;
		sout << "\n NVec =  "<<Ndir[0];
		sout << "\n\n";
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
	
}

template <class T>
void TPZYCModifiedMohrCoulomb::GradLodeAngle(const TPZTensor<T> &sigma, TPZTensor<T> &grad,T &theta) const
{
	T J2 = sigma.J2();
	if(shapeFAD::val(J2) < 1.e-6)J2 = 1.e-6;
	T J3 = sigma.J3();
	
	T temp = ( T( 3.) * sqrt( T( 3.) ) * J3 ) /( T( 2.) *  sqrt(J2*J2*J2) );
	if( temp >= T(1.))
	{
		temp*=T(0.999);
	}
	if(temp <= T(-1.))
	{
		temp*=T(0.999);
	}
	theta=-asin( temp )/T( 3.);
	
	TPZTensor<T> dJ2, dJ3;
	sigma.dJ2(dJ2);
	sigma.dJ3(dJ3);
//	dJ2.Multiply(T(3.)*J3,T(1.));
//	dJ3.Multiply(T(2.)*J2, T(1.));
//	dJ2.Add(dJ3,T(-1.));
//	dJ2.Multiply(T(1.)/(T(2.)*sqrt(J2*J2*J2*J2*J2)*sqrt((T(4./5.)) - (T(9.) * (J3*J3))/(J2*J2*J2) ) ), T(1.));

//	T temp1 = T(3.)*J3;
//	T temp2 = -T(2.)*J2;
//	T temp3 = T(2.)*sqrt(J2*J2*J2*J2*J2);
//	T temp44 =  T(9.)*(J3*J3) / (J2*J2*J2 ) ;
//	if(fabs(shapeFAD::val(temp44)) >= (4./3.))temp44 *= 0.99;
//	T temp4 = sqrt(T(4./3.) - ( temp44 ));
//	TPZTensor<T> resultdj2(dJ2);
//	TPZTensor<T> resultdj3(dJ3);
//	
//	resultdj2.Multiply(temp1, T(1.));
//	resultdj3.Multiply(temp2,T(1.));
//	resultdj2.Add(resultdj3,T(1.));
//	resultdj2.Multiply(T(1.)/(temp3*temp4), T(1.));
	
	T temp1= -( T(9.*sqrt(3.)) * J3) / ( T(4.)*sqrt(J2*J2*J2*J2*J2) );
	TPZTensor<T> resultdj2(dJ2);
	resultdj2.Multiply(temp1,T(1.));
	
	T temp2 = ( T(3.)*sqrt( T( 3. ) ) )/ ( T( 2. ) * sqrt( J2 * J2 * J2 ) );
	TPZTensor<T> resultdj3(dJ3);
	resultdj3.Multiply(temp2,T(1.));
	
	T temp33 = ( T( 27. ) * ( J3 * J3 ) )/( T( 4. ) *  J2 * J2 * J2);
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n temp33 \n"<<endl;
		sout << temp33 << endl;
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
	if(shapeFAD::val(temp33) >= 0.99999)temp33 *= 0.999998;
	T temp3 = ( T( 3. )  *  sqrt( T( 1. )- temp33 ));
	
//	grad(resultdj2);
//	grad.Add(resultdj2,T(1.));
//	grad.Multiply(T(1.)/temp3, T(-1));
//  grad=(T(3.)*J3*dJ2 - T(2.)*J2*dJ3)/(T(2.)*pow(J2,T(2.5))*sqrt(T(1.3333333333333333) - (T(9.)*pow(J3,T(2.)))/pow(J2,T(3.))));
	
	TPZTensor<T>  RESULT(resultdj2);
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n resultdj2 \n"<<endl;
		sout << resultdj2 << endl;
		sout << "\n resultdj3 \n"<<endl;
		sout << resultdj3 << endl;
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
//	resultdj2.Multiply(T(1.)/temp3,T(1.));
//	resultdj3.Multiply(T(1.)/temp3,T(1.));
	resultdj2.Add(resultdj3, T(1.));
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n nemerador \n"<<endl;
		sout << resultdj2 << endl;
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
	resultdj2.Multiply( T(1.) / temp3 ,T(-1.));
	
	grad.XX()=resultdj2.XX();
	grad.XY()=resultdj2.XY();
	grad.XZ()=resultdj2.XZ();
	grad.YY()=resultdj2.YY();
	grad.YZ()=resultdj2.YZ();
	grad.ZZ()=resultdj2.ZZ();
	
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\nDERIV LODE ANGLE "<<endl;
		sout << " sigma "<<endl;
		sout << sigma << endl;
		sout << " dj2"<<endl;
		sout << dJ2 << endl;
		sout << " dj3 "<<endl;
		sout << dJ3 << endl;
		sout << " J2 "<<endl;
		sout << J2 << endl;
		sout << " J3 "<<endl;
		sout << J3 << endl;
		sout << " temp1 "<<endl;
		sout << temp1 << endl;
		sout << " temp2 "<<endl;
		sout << temp2 << endl;
		sout << " temp3 "<<endl;
		sout << temp3 << endl;
		sout << " temp44 "<<endl;
		sout << temp33 << endl;
		sout << " grad "<<endl;
		sout << resultdj2 << endl;
		sout << "\n\n";
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
	
}

template <class T>
void TPZYCModifiedMohrCoulomb::dpart1(const TPZTensor<T> &sigma, TPZTensor<T> &grad) const
{
	TPZTensor<T> gradtheta;
	T theta;
	GradLodeAngle<T> (sigma, gradtheta,theta);
	
	T sqj2 = sqrt(sigma.J2());
	TPZTensor<T> dj2,di1,I;
	sigma.dJ2(dj2);
	di1.XX()=1.;
	di1.YY()=1.;
	di1.ZZ()=1.;
	REAL Phi = 0.349066;
	I.Identity();
	T J2=sigma.J2();
	T J3=sigma.J3();
	
	dj2.Multiply(T(1.)/( cos( theta ) ) / ( T( 2. ) * sqrt(J2) ),T(1.) );
	
	T temppart12 = sqrt(J2) * sin(theta);
	gradtheta.Multiply(temppart12, T( -1. ));
	TPZTensor<T> resultpart1(gradtheta);
	
	resultpart1.Add(dj2,T(1.));
//	grad(resultpart1);
	
	grad.XX()=resultpart1.XX();
	grad.XY()=resultpart1.XY();
	grad.XZ()=resultpart1.XZ();
	grad.YY()=resultpart1.YY();
	grad.YZ()=resultpart1.YZ();
	grad.ZZ()=resultpart1.ZZ();
//	
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n\nTANGENT \n";
		sout << grad<<endl;
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
}


template <class T>
void TPZYCModifiedMohrCoulomb::respart1(const TPZTensor<T> &sigma, REAL &phi) const
{
	TPZTensor<T> gradtheta;
	T theta;
	GradLodeAngle<T> (sigma, gradtheta,theta);
	
	T J2=sigma.J2();
	
	phi = cos( theta )*sqrt(J2);
	
#ifdef LOG4CXX_PLASTICITY
	{
		std::stringstream sout;
		sout << "\n\nRESIDUAL \n";
		sout << phi<<endl;
		LOGPZ_INFO(logModifiedMohr,sout.str());
	}
#endif
	
}

template <class T>
void TPZYCModifiedMohrCoulomb::dpart2(const TPZTensor<T> &sigma, TPZTensor<T> &grad) const
{
}


template <class T>
void TPZYCModifiedMohrCoulomb::respart2(const TPZTensor<T> &sigma, REAL &phi) const
{
}

#endif