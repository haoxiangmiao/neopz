/**
 * @file
 * @brief Contains the implementation of the TPZStepSolver methods.
 */
/* Generated by Together */

#include "pzstepsolver.h"
#include <stdlib.h>
using namespace std;

#include "pzlog.h"

#ifdef LOG4CXX
static LoggerPtr logger(Logger::getLogger("pz.converge"));
#endif

TPZStepSolver::TPZStepSolver(TPZAutoPointer<TPZMatrix> refmat) : TPZMatrixSolver(refmat) {
	fPrecond = 0;
	ResetSolver();
}

TPZStepSolver::TPZStepSolver(const TPZStepSolver & copy) : TPZMatrixSolver(copy), fSingular(copy.fSingular) {
    fSolver = copy.fSolver;
    fDecompose = copy.fDecompose;
    fNumIterations = copy.fNumIterations;
    fTol = copy.fTol;
    fOverRelax = copy.fOverRelax;
    fPrecond = 0;
    if(copy.fPrecond) fPrecond = copy.fPrecond->Clone();
    fFromCurrent = copy.fFromCurrent;
    fNumVectors = copy.fNumVectors;//Cedric: 24/04/2003 - 12:39
}

TPZStepSolver::~TPZStepSolver() {
	if(fPrecond) delete fPrecond;
}
/**
 This method will reset the matrix associated with the solver
 This is useful when the matrix needs to be recomputed in a non linear problem
 */
void TPZStepSolver::ResetMatrix()
{
	TPZMatrixSolver::ResetMatrix();
}

/**
 * @brief Decompose the system of equations if a direct solver is used
 */
void TPZStepSolver::Decompose()
{
    if (fSolver == EDirect) {
        Matrix()->Decompose(fDecompose,fSingular);
    }
}


void TPZStepSolver::Solve(const TPZFMatrix &F, TPZFMatrix &result, TPZFMatrix *residual){
	if(!Matrix()) {
		cout << "TPZMatrixSolver::Solve called without a matrix pointer\n";
		DebugStop();
	}
	
	TPZAutoPointer<TPZMatrix> mat = Matrix();
    // update the matrix to which the preconditioner refers
    if(fPrecond)
    {
        
        fPrecond->UpdateFrom(Matrix());
    }
    
	if(result.Rows() != mat->Rows() || result.Cols() != F.Cols()) {
		result.Redim(mat->Rows(),F.Cols());
	}
	
	if(fScratch.Rows() != result.Rows() || fScratch.Cols() != result.Cols()) {
		fScratch.Redim(result.Rows(),result.Cols());
	}
	
	REAL tol = fTol;
	int numiterations = fNumIterations;
	switch(fSolver) {
		case ENoSolver:
		default:
			cout << "TPZMatrixSolver::Solve called without initialized solver, Jacobi used\n";
			SetJacobi(1,0.,0);
		case EJacobi:
			//    cout << "fScratch dimension " << fScratch.Rows() << ' ' << fScratch.Cols() << endl;
			mat->SolveJacobi(numiterations,F,result,residual,fScratch,tol,fFromCurrent);
			break;
		case ESOR:
			mat->SolveSOR(numiterations,F,result,residual,fScratch,fOverRelax,tol,fFromCurrent);
			break;
		case ESSOR:
			mat->SolveSSOR(numiterations,F,result,residual,fScratch,fOverRelax,tol,fFromCurrent);
			break;
		case ECG:
			mat->SolveCG(numiterations,*fPrecond,F,result,residual,tol,fFromCurrent);
#ifdef LOG4CXX
		{
			std::stringstream sout;
			sout << "Number of equations " << mat->Rows() << std::endl;
			sout << "Number of CG iterations " << numiterations << " tol = " << tol;
			LOGPZ_DEBUG(logger,sout.str().c_str());
		}
#endif
			break;
		case EGMRES: {
			TPZFMatrix H(fNumVectors+1,fNumVectors+1,0.);
			mat->SolveGMRES(numiterations,*fPrecond,H,fNumVectors,F,result,residual,tol,fFromCurrent);
			if(numiterations == fNumIterations || tol >= fTol)
			{
				std::cout << "GMRes tolerance was not achieved : numiter " << numiterations <<
				" tol " << tol << endl;
			}
#ifdef LOG4CXX
			{
				std::stringstream sout;
				sout << "Number of GMRES iterations " << numiterations << " tol = " << tol;
				LOGPZ_DEBUG(logger,sout.str().c_str());
			}
#endif
		}
			break;
		case EBICGSTAB: 
			mat->SolveBICGStab(numiterations, *fPrecond, F, result,residual,tol,fFromCurrent);
			
			if(numiterations == fNumIterations || tol >= fTol)
			{
				std::cout << "BiCGStab tolerance was not achieved : numiter " << numiterations <<
				" tol " << tol << endl;
			}
#ifdef LOG4CXX
		{
			std::stringstream sout;
			sout << "Number of BiCGStab iterations " << numiterations << " tol = " << tol;
			LOGPZ_DEBUG(logger,sout.str().c_str());
		}
#endif
			break;
		case EDirect:
			result = F;
			mat->SolveDirect(result,fDecompose,fSingular);
			if(residual) residual->Redim(F.Rows(),F.Cols());
			break;
		case EMultiply:
			mat->Multiply(F,result);
			if(residual) mat->Residual(result,F,*residual);
			
	}
}
void TPZStepSolver::ResetSolver() {
	fSolver = ENoSolver;
	fDecompose  = ENoDecompose;
	fNumIterations = 0;
	fTol = 0.;
	fNumVectors = 0;
	fOverRelax = 0.;
	if(fPrecond) delete fPrecond;
	fPrecond = 0;
	fFromCurrent = 0;
}
void TPZStepSolver::SetDirect (const DecomposeType decomp){
	ResetSolver();
	fSolver = EDirect;
	fDecompose = decomp;
}
void TPZStepSolver::SetCG(const int numiterations, const TPZMatrixSolver &pre, const REAL tol, const int FromCurrent){
	ResetSolver();
	fSolver = ECG;
	fNumIterations = numiterations;
	fTol = tol;
	//	fPrecond = &pre;
	if(fPrecond) delete fPrecond;
	fPrecond = pre.Clone();
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetGMRES(const int numiterations, const int numvectors, const TPZMatrixSolver &pre, const REAL tol, const int FromCurrent){
	ResetSolver();
	fSolver = EGMRES;
	fNumVectors = numvectors;
	fNumIterations = numiterations;
	fTol = tol;
	//	fPrecond = &pre;
	if(fPrecond) delete fPrecond;
	fPrecond = pre.Clone();
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetBiCGStab(const int numiterations, const TPZMatrixSolver &pre,const REAL tol,const int FromCurrent){
	ResetSolver();
	fSolver = EBICGSTAB;
	fNumIterations = numiterations;
	fTol = tol;
	//	fPrecond = &pre;
	if(fPrecond) delete fPrecond;
	fPrecond = pre.Clone();
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetJacobi(const int numiterations, const REAL tol, const int FromCurrent) {
	ResetSolver();
	fSolver = EJacobi;
	fNumIterations = numiterations;
	fTol = tol;
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetSSOR(const int numiterations,const REAL overrelax,const REAL tol,const int FromCurrent) {
	ResetSolver();
	fSolver = ESSOR;
	fOverRelax = overrelax;
	fNumIterations = numiterations;
	fTol = tol;
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetSOR(const int numiterations,const REAL overrelax,const REAL tol,const int FromCurrent){
	ResetSolver();
	fSolver = ESOR;
	fNumIterations = numiterations;
	fOverRelax = overrelax;
	fTol = tol;
	fFromCurrent = FromCurrent;
}
void TPZStepSolver::SetMultiply() {
	ResetSolver();
	fSolver = EMultiply;
}


/*!
 \fn TPZStepSolver::SetPreconditioner(TPZSolver &solve);
 */
void TPZStepSolver::SetPreconditioner(TPZSolver &solve)
{
    if (fSolver == EDirect) {
        DebugStop();
    }
	if(fPrecond) delete fPrecond;
	fPrecond = solve.Clone();
}

void TPZStepSolver::Write(TPZStream &buf, int withclassid)
{
	TPZSolver::Write(buf, withclassid);
	fPrecond->Write(buf, 1);
	int lfSolver = fSolver;
	buf.Write(&lfSolver, 1);
	int lfDT = fDecompose;
	buf.Write(&lfDT, 1);
	buf.Write(&fNumIterations, 1);
	buf.Write(&fNumVectors, 1);
	buf.Write(&fTol, 1);
	buf.Write(&fOverRelax, 1);
	buf.Write(&fFromCurrent, 1);
	int size = fSingular.size();
	buf.Write(&size, 1);
	std::list<int>::iterator it = fSingular.begin();
	for(;it != fSingular.end(); it++)
	{
		buf.Write(&*it, 1);
	}
}
void TPZStepSolver::Read(TPZStream &buf, void *context)
{
	TPZSolver::Read(buf, context);
	fPrecond = dynamic_cast<TPZSolver *>(TPZSaveable::Restore(buf, context));
	
	int lfSolver = 0;
	buf.Read(&lfSolver, 1);
	fSolver = (TPZMatrixSolver::MSolver)lfSolver;
	int lfDT = 0;
	buf.Read(&lfDT, 1);
	fDecompose = (DecomposeType)lfDT;
	buf.Read(&fNumIterations, 1);
	buf.Read(&fNumVectors, 1);
	buf.Read(&fTol, 1);
	buf.Read(&fOverRelax, 1);
	buf.Read(&fFromCurrent, 1);
	int size = 0;
	buf.Read(&size, 1);
	fSingular.resize(size);
	std::list<int>::iterator it = fSingular.begin();
	for(;it != fSingular.end(); it++)
	{
		buf.Read(&*it, 1);
	}
}

template class TPZRestoreClass< TPZStepSolver, TPZSTEPSOLVER_ID>;
