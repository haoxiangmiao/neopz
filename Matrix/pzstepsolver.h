/**
 * @file
 * @brief Contains TPZStepSolver class which defines step solvers class.
 */
/* Generated by Together */

#ifndef TPZSTEPSOLVER_H
#define TPZSTEPSOLVER_H
#include "pzsolve.h"

#include "pzstream.h"

#include <list>
class TPZFMatrix;

/** @ingroup solvers */
#define TPZSTEPSOLVER_ID 28291007

/**
 @brief Defines step solvers class. \ref solver "Solver"
 @ingroup solver
 */
class TPZStepSolver: public TPZMatrixSolver
{
public:
	TPZStepSolver(TPZAutoPointer<TPZMatrix> refmat = 0);
	
	TPZStepSolver(const TPZStepSolver & copy);
	
	virtual ~TPZStepSolver();
	
	void SetSOR(const int numiterations, const REAL overrelax, const REAL tol,
				const int FromCurrent);
	
	void SetSSOR(const int numiterations, const REAL overrelax, const REAL tol,
				 const int FromCurrent);
	
	void
	SetJacobi(const int numiterations, const REAL tol, const int FromCurrent);
	
	void SetCG(const int numiterations, const TPZMatrixSolver &pre,
			   const REAL tol, const int FromCurrent);
	
	void SetGMRES(const int numiterations, const int numvectors,
				  const TPZMatrixSolver &pre, const REAL tol, const int FromCurrent);
	
	void SetBiCGStab(const int numiterations, const TPZMatrixSolver &pre,
					 const REAL tol, const int FromCurrent);
	
	void SetDirect(const DecomposeType decomp);
	
	void SetMultiply();
	
	virtual TPZSolver *Clone() const
	{
		return new TPZStepSolver(*this);
	}
	
	void SetTolerance(REAL tol)
	{
		fTol = tol;
	}
	
    /** @brief reset the data structure of the solver object */
	void ResetSolver();
    
    virtual MSolver Solver()
    {
        return fSolver;
    }
	
	/**
	 * @brief returns the equations for which the equations had zero pivot
	 */
	std::list<int> &Singular()
	{
		return fSingular;
	}
	
	/** @brief This method will reset the matrix associated with the solver */
	/** This is useful when the matrix needs to be recomputed in a non linear problem */
	virtual void ResetMatrix();

	/**
	 * @brief Updates the values of the current matrix based on the values of the matrix
	 */
	virtual void UpdateFrom(TPZAutoPointer<TPZMatrix> matrix)
	{
		if (fPrecond)
			fPrecond->UpdateFrom(matrix);
		TPZMatrixSolver::UpdateFrom(matrix);
	}
	
    
	void Solve(const TPZFMatrix &F, TPZFMatrix &result, TPZFMatrix *residual = 0);
    
    /**
     * @brief Decompose the system of equations if a direct solver is used
     */
    virtual void Decompose();
    
    /** @brief Define the preconditioner as a solver object */
	void SetPreconditioner(TPZSolver &solve);
    
    /** @brief access method to the preconditioner */
    TPZSolver *PreConditioner()
    {
        return fPrecond;
    }
	
	/** @brief Serialization methods */
	virtual int ClassId() const
	{
		return TPZSTEPSOLVER_ID;
	}
	virtual void Write(TPZStream &buf, int withclassid);
	virtual void Read(TPZStream &buf, void *context);
	
	
private:
	MSolver fSolver;
	DecomposeType fDecompose;
	int fNumIterations;
	int fNumVectors;
	REAL fTol;
	REAL fOverRelax;
	
	/** @brief Solver using preconditioner matrix */
	TPZSolver *fPrecond;
	int fFromCurrent;
	
	std::list<int> fSingular;
};

#endif //TPZSTEPSOLVER_H
